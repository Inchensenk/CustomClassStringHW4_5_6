#pragma once
#include <iostream>
#include<string>
using namespace std;
class StringEx
{
private:
    //указатель на массив char, хранит символы которые мы передали в наш объект
    char* str;

    //length переменная, хранящая количество символов в строке
    int length;
public:
    char* getStr();
    

    int getLength();
    

    //-КОНСТРУКТОР ПО УМОЛЧАНИЮ (БЕЗ ПАРАМЕТРОВ)
    //если просто нужно создать объект класса стринг и ничего ему не присваивать
    StringEx();
    
            
    //-КОНСТРУКТОР С ПАРАМЕТРОМ, В КОТОРЫЙ МЫ ПОМЕЩАЕМ МАССИВ CHAR 
    //при создании объекта класса необходимо передать строку, которую он будет хранить 
    StringEx(const char* str);
    

    /*Конструктор копирования нужен для того, чтобы мы могли один подобный объект нашего класса скопировать в другой и не получить при этом ошибку при работе с динамической памятью потому,
    что по умолчанию такой конструктор копирует все поля абсолютно идентично, если мы не сделаем конструктор копирования как он реализован ниже, то мы получим ошибку памяти из-за того, 
    что у нас 2 указателя, в объекте из которого мы копировали и в объекте, в который мы копировали будут указывать на одну и ту же область динамической памяти, 
    а когда 2 таких объекта будут выходить из области видимости какой-то функции то у нас 2 раза для одной и той же области, для одной и той же динамической памяти, 
    вызовется деструктор, собственно, мы попытаемся оператором delete два раза освободить ресурсы с одной и той же области памяти, что спровоцирует ошибку. */

    //КОНСТРУКТОР КОПИРОВАНИЯ, необходим для создания точной копии объекта класса, но в другой области памяти
    StringEx(const StringEx& other);
    
        
    /*Перегрузка оператора сложения, который будет возвращать объект StringEx*/

    //ПЕРЕГРУЗКА ОПЕРАТОРА СЛОЖЕНИЯ ДЛЯ КОНКАТЕНАЦИИ СТРОКИ 
    StringEx operator + (const StringEx& other);
    


    /*перегруженный оператор присваивания практически то же самое что конструктор копирования
    только мы еще заранее проверяем нет ли у нас в текущем объекте уже каких-то данных и если есть,
    то мы наши ресурсы освобождаем и делаем тоже самое что в нашем конструкторе копирования    
    оператор '=' должен возвращать ссылку на тип нашего класса, 
    функция должна принимать в себя константную ссылку на объект нашего класса*/

    //ПЕРЕГРУЗКА ОПЕРАТОРА ПРИСВАИВАНИЯ '='
    StringEx& operator = (const StringEx& other);
    

    /*перегрузка оператора "[]" для получения символа, хронящегося под индексом массива,
    индекс задаем как входной параметр.
    Чтобы можно было менять букву в массиве строк по индексу, нужно возвращать ссылку*/

    //ПЕРЕГРУЗКА ОПЕРАТОРА ИНДЕКСАЦИИ "[]" 
    char& operator [](int index);
    

    /*конструктор перемещения.
    при конкотанации когда мы создаем новую переменную которая будет содержать часть строчек, по сути нужно создать новый объект
    мы его создаем и как результат есть новый результирующий объект, когда возвращается его значение
    вместо того чтобы просто сказать переменной, что вот мы создали новый объект ты просто возми его и используй.
    Мы так не делаем, а попадаем в конструктор копирования где создается новая область динамической памяти
    и мы поэлементно перетаскиваем все буквы с того объекта.
 
    По сути конструктор перемещения указывает переменной на обьект, чтобы переменная его сразу использвала
    синтаксис чем-то похож на конструктор копирования.

    Нам нужно принять ссылку на ссылку на обьект.
    Такая конструкция позволит сразу сказать что мы берем обьект и сразу используем его*/

    //КОНСТРУКТОР ПЕРЕМЕЩЕНИЯ, нужен для того чтобы существенно оптимизировать код и ускорить работу программы
    StringEx(StringEx&& other);
    

    int Length();
    

    //size(), Опроеделение длинны строки
    static int size(char* str);
    

    /*перегрузка оператора равенства ==()
    так как мы сравниваем 2 объекта, то фактический объект который мы принимаем как входящий параметр при перегрузке оператора обычно пишут так:
    ""const" потом тип данных, с котрым мы хотим сравнивать StringEx и далее ссылка '&' на объект "other", с которым мы будем сравнивать".
    Константная ссылка на тип данных значит, что мы не копируем объект, а просто заглядываем по какому то адресу и смотрим на состояние полей этого объекта.
    Поменять мы там ничего не можем, потому что константная ссылка, а ссылка именно потому, что нам не нужно сюда копировать весь объект и засорять ОЗУ 
    и тратить какие-то ресурсы на операции копирования. Мы можем просто посмотреть что там лежит, по этому мы передаем по ссылке.
         Что мы должны сделать для того чтобы понять две строки между собой равны или нет?
    Прежде чем писать какой-то код, нам нужно сначало логически подумать как это сделать? Если в2-х строчках разное колличество символов, понятное дело что строчки вообще между собой не равны.
    Что подразумевается под равенством строк? Этот значит что у нас два абсолютно идентичных слова, то есть если бы у нас было два слова Hello то понятно что они одинаковы.
    Раз у нас тот момент, когда 2 строки имеют разное колличество символов уже явно дает понять что строчки разные, нам уже не нужно посимвольно проверять, сразу можно сделать вывод что они не равны.
    Поэтому если поле length текущего объекъта, о том что это текущий обьект нам говорит указатель this, не равно полю length обьекта other (other.length), который мы сюда передаем как параметр,
    то мы уже сразу можем сделать вывод что эти 2 строки неравны. Поэтому можем сделать сразу возврат значения false
    Если поля равны, то пробегаем по строкам через for так как у них одинаковое колличество символов то мы можем итерироваться столько раз сколько символов либо  в одной либо в другой строчке, 
    поэтому можно взять просто поле length, так ка мы находимся в классе то оно нам подойдет. 
    Но для того чтобы ввести ясность можно написать вот так this->length
    в цикле пишем еще одно условие: если хотябы один элемент в массиве, который именно в текущем классе, который у нас хранит все char-ы, будет неравен, тому элементу, который находится в тойже позиции
    только в объекте other, который мы передали ему как параметр, то мы уже сразу можем понять что наши объекты между собой неравны и можем сразу вернуть false.
    Есть маленький ньюанс, не все ветви этого кода возвращают значение, если мы видим что переменные не равны между собой, мы возвращаем false
    и если мы находим хотябы 1 символ который в той же позиции не равен символу в другом объекте, мы возвращаем false и сразу выходим, 
    но если оба условия не выполнилось и длинна у нас одинаковая то логично что наши строки будут тоже одинаковые, поэтому  в этом случае мы возвращаем true,
    то есть мы дошли до такого момента когда мы точно можем сказать, что в этом случае наши с вами строчки абсолютно идентичны*/

    //ПЕРЕГРУЗКА ОПЕРАТОРА РАВЕНСТВА "=="
    bool operator ==(const StringEx& other);
    

    /*в данном случее метод operator !=() рекурсивно вызовет метод operator==() и вернет результат метода  operator==(),но операция не равно по своей сути инверсивна 
    и возвращает инверсированный результат, поэтому если мы получим в методе operator==() true, то в метод operator !=() вернется false*/

    //ПЕРЕГРУЗКА ОПЕРАТОРА НЕРАВЕНСТВА "!="
    bool operator !=(const StringEx& other);
    

    void print();
    

    
    //ДЕСТРУКТОР,отвечает за освобождение ресурсов занятых объектом, вызывается при уничтожении объекта класса
    ~StringEx();
    


    static int find(char* str, char k);
    


    int find(char k);
    
    //описание дано ниже
    static int contains(char* str, char* substr);
    
    //метод возвращает первое вхождение подстроки в строку, с левого конца
    int contains(char* substr);
    

    //мето вставляет заданный текст insertStr на позицию index в str(исходная строка)
    static char* insert(char* str, char* insertStr, int index);
    
    
    char* insert(char* insertStr, int index);
        

    //возвращает колличество вхождений символа в строку
    static int count(char* str, char sep);
    

    //возвращает колличество вхождений символа в строку
    int count(char sep);
    

    //коментарии приведены ниже в перегрузке метода split()
    static char** split(char* str, char sep, bool print = true);
    
    //РАЗДЕЛЕНИЕ СТРОКИ НА ПОДСТРОКИ
    char** split(char sep, bool print = true);
    

};

