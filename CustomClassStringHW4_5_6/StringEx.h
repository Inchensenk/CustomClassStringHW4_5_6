#pragma once
#include <iostream>
#include<string>
using namespace std;
class StringEx
{
private:
    //указатель на массив char, хранит символы которые мы передали в наш объект
    char* str;

    //length переменная, хранящая количество символов в строке
    int length;
public:

    //-КОНСТРУКТОР ПО УМОЛЧАНИЮ (БЕЗ ПАРАМЕТРОВ)
    //если просто нужно создать объект класса стринг и ничего ему не присваивать
    StringEx()
    {
        str = nullptr;
        length = 0;
    }
            
    //-КОНСТРУКТОР С ПАРАМЕТРОМ, В КОТОРЫЙ МЫ ПОМЕЩАЕМ МАССИВ CHAR 
    //при создании объекта класса необходимо передать строку, которую он будет хранить 
    StringEx(const char* str)
    {
        //strlen() считает количество символов в строке, которую мы передаем, пока не наткнется на '\0'(терминальный ноль она не учитывает)
        //для того, чтобы знать сколько места нам нужно будет выделить в динамической памяти под наш новый массив

        //присвоим значение, которое вернет функция strlen(), полю length 
        length = strlen(str);
                 
        //создаем новый массив в динамической памяти на единицу больше массива который приняли чтобы учитывать '\0'
        this->str = new char[length + 1];
           
        //присваиваем поэлементно значения из принимаемого массива массиву объекта класса, находящемуся в private зоне
        for (int i = 0; i < length; i++)
        {
            this->str[i] = str[i];
        }

        //обьявление конца строки, чтобы знать где конец той строки, которая у нас теперь хранится в нашем объекте класса  
        this->str[length] = '\0';
    }

    /*Конструктор копирования нужен для того, чтобы мы могли один подобный объект нашего класса скопировать в другой и не получить при этом ошибку при работе с динамической памятью потому,
    что по умолчанию такой конструктор копирует все поля абсолютно идентично, если мы не сделаем конструктор копирования как он реализован ниже, то мы получим ошибку памяти из-за того, 
    что у нас 2 указателя, в объекте из которого мы копировали и в объекте, в который мы копировали будут указывать на одну и ту же область динамической памяти, 
    а когда 2 таких объекта будут выходить из области видимости какой-то функции то у нас 2 раза для одной и той же области, для одной и той же динамической памяти, 
    вызовется деструктор, собственно, мы попытаемся оператором delete два раза освободить ресурсы с одной и той же области памяти, что спровоцирует ошибку. */

    //КОНСТРУКТОР КОПИРОВАНИЯ, необходим для создания точной копии объекта класса, но в другой области памяти
    StringEx(const StringEx& other)
    {
        //берем размер принемаемого массива и присваеиваем это значение полю length
        length = strlen(other.str);

        //выделяем новый динамический массив при копировании одного объекта в другой
        this->str = new char[length + 1];//выделяем место в динамической памяти для нового массива char

        //и поэлементно все это дело копируем чтобы при вызове деструктора не было проблем с динамической памятью
        for (int i = 0; i < length; i++)
        {
            this->str[i] = other.str[i];// проходим по элементам 2х массивов и из одного массива присваиваем поэлементно значения в другой массив
        }
        this->str[length] = '\0';//обьявление конца строки
    }
        
    /*Перегрузка оператора сложения, который будет возвращать объект StringEx*/

    //ПЕРЕГРУЗКА ОПЕРАТОРА СЛОЖЕНИЯ ДЛЯ КОНКАТЕНАЦИИ СТРОКИ 
    StringEx operator + (const StringEx& other)
    {
        //создаем новый объект класса
        StringEx newStr;

        //так как нам нужно знать какого размера будет указатель который будет хранить строку,
        // нам будут нужны 2 переменные ,когда мы будем выделять место в нашем новом объекте в его указатель str через оператор new 

        //хранит длинну массива char, который в текущей строчке
        int thisLength = strlen(this->str);

        //определяем сколько места занимает строка, которую мы передаем
        int otherLength = strlen(other.str);

        //присваиваем значение длинны результирующего массива char (длины результирующей строки) полю length объекта newStr
        newStr.length = thisLength + otherLength;

        //с помощью оператора new выделяем в нашем новом массиве место равное сумме длин двух массивов + 1 для '\0'
        newStr.str = new char[newStr.length + 1];

        //теперь у нас есть новый массив, в котрый мы должны присвоить все элементы из двух массивов из которых мы складываем новую строчку
        //для этого используем два цикла

        //первый цикл переберет массив который находится в this и присвоить в наш новый объект все свои символы 
        //так как во втором цикле нужно дозаписать результирующий массив, то вынесем i перед первым for, чтобы i во втором for начиналась не с 0-ля 
        int i = 0;
        for (; i < thisLength; i++)
        {
            newStr.str[i] = this->str[i];
        }

        //второй цикл будет помещать обьекты второго массива в новую строку
        //мы должны здесь итерироваться с помощью оператора i
        for (int j = 0; j < otherLength; j++, i++)
        {
            newStr.str[i] = other.str[j];
        }
        //после того как все элементы помещены в новый массив, добавляем '\0' для обозначения конца строки
        newStr.str[newStr.length] = '\0';

        //теперь возвращаем объект, который мы создали, как результат работы оператора '+' (нашей функции)
        return newStr;
    }


    /*перегруженный оператор присваивания практически то же самое что конструктор копирования
    только мы еще заранее проверяем нет ли у нас в текущем объекте уже каких-то данных и если есть,
    то мы наши ресурсы освобождаем и делаем тоже самое что в нашем конструкторе копирования    
    оператор '=' должен возвращать ссылку на тип нашего класса, 
    функция должна принимать в себя константную ссылку на объект нашего класса*/

    //ПЕРЕГРУЗКА ОПЕРАТОРА ПРИСВАИВАНИЯ '='
    StringEx& operator = (const StringEx& other)
    {   
        //если наш указатель не nullptr (значит в нем что-то есть)
        if (this->str != nullptr)
        {
            //то очищаем динамическую память
            delete[]str;
        }

        //берем размер принимаемого массива и присваиваем значение полю length 
        length = strlen(other.str);

        //выделяем место в динамической памяти для нового массива char
        this->str = new char[length + 1];

        //поэлементно присваиваем значения из принимаемой строки, строке объекта класса 
        for (int i = 0; i < length; i++)
        {
            this->str[i] = other.str[i];
        }
        //обьявление конца строки
        this->str[length] = '\0';

        //возвращаем разименованный указатель, потому что мы возвращаем ссылку на текущий объект нашего класса
        return *this; 
    }

    /*перегрузка оператора "[]" для получения символа, хронящегося под индексом массива,
    индекс задаем как входной параметр.
    Чтобы можно было менять букву в массиве строк по индексу, нужно возвращать ссылку*/

    //ПЕРЕГРУЗКА ОПЕРАТОРА ИНДЕКСАЦИИ "[]" 
    char& operator [](int index)
    {
        return this->str[index];
    }

    /*конструктор перемещения.
    при конкотанации когда мы создаем новую переменную которая будет содержать часть строчек, по сути нужно создать новый объект
    мы его создаем и как результат есть новый результирующий объект, когда возвращается его значение
    вместо того чтобы просто сказать переменной, что вот мы создали новый объект ты просто возми его и используй.
    Мы так не делаем, а попадаем в конструктор копирования где создается новая область динамической памяти
    и мы поэлементно перетаскиваем все буквы с того объекта.
 
    По сути конструктор перемещения указывает переменной на обьект, чтобы переменная его сразу использвала
    синтаксис чем-то похож на конструктор копирования.

    Нам нужно принять ссылку на ссылку на обьект.
    Такая конструкция позволит сразу сказать что мы берем обьект и сразу используем его*/

    //КОНСТРУКТОР ПЕРЕМЕЩЕНИЯ, нужен для того чтобы существенно оптимизировать код и ускорить работу программы
    StringEx(StringEx&& other)
    {
        //нашему текущему объекту присваиваем значение принимаемого параметра other.length
        this->length = other.length;

        /*далее просто берем и в наш указатель который указывает на массив в динамической памяти присваиваем адрес
         такого же самого массива только в объекте other, таким образом мы его не копируем поэлементно а просто говорим:
         "вон он теперь по тому адресу, ты теперь на него ссылайся и сним работай"*/
        this->str = other.str;

        /*Для того чтобы наш объект не уничтожился нам нужно запретить удалять эти данные, обращаемся к этому объекту к его указателю и присваиваем nullptr. 
        Таким образом мы запрещаем удалять данные на которые он ссылается, так как нам нужно внести изменения в объект other то ключевое слово const в сигнатуре не нужно*/
        other.str = nullptr;
    }

    int Length()
    {
        //заботимся о том чтобы хранить заранее информацию о нашей строке, 
        //чтобы каждый раз при обращении к методу ленз заново не бежать и считаь это колличество
        //чтобы было меньще накладок на производительность
        return length;
    }

    //size(), Опроеделение длинны строки
    int size(char* str)
    {
        //обьявляем переменную для подсчета символов и присваиваем ей 0
        int counter = 0;

        //пока значение индекса массива строк не будет равна '\0'
        while (str[counter] != '\0')
        {
            //увеличиваем счетчик на 1
            counter++;
        }

        //возвращаем количество символов в строке как результат работы метода size() 
        return counter;
    }

    /*перегрузка оператора равенства ==()
    так как мы сравниваем 2 объекта, то фактический объект который мы принимаем как входящий параметр при перегрузке оператора обычно пишут так:
    ""const" потом тип данных, с котрым мы хотим сравнивать StringEx и далее ссылка '&' на объект "other", с которым мы будем сравнивать".
    Константная ссылка на тип данных значит, что мы не копируем объект, а просто заглядываем по какому то адресу и смотрим на состояние полей этого объекта.
    Поменять мы там ничего не можем, потому что константная ссылка, а ссылка именно потому, что нам не нужно сюда копировать весь объект и засорять ОЗУ 
    и тратить какие-то ресурсы на операции копирования. Мы можем просто посмотреть что там лежит, по этому мы передаем по ссылке.
         Что мы должны сделать для того чтобы понять две строки между собой равны или нет?
    Прежде чем писать какой-то код, нам нужно сначало логически подумать как это сделать? Если в2-х строчках разное колличество символов, понятное дело что строчки вообще между собой не равны.
    Что подразумевается под равенством строк? Этот значит что у нас два абсолютно идентичных слова, то есть если бы у нас было два слова Hello то понятно что они одинаковы.
    Раз у нас тот момент, когда 2 строки имеют разное колличество символов уже явно дает понять что строчки разные, нам уже не нужно посимвольно проверять, сразу можно сделать вывод что они не равны.
    Поэтому если поле length текущего объекъта, о том что это текущий обьект нам говорит указатель this, не равно полю length обьекта other (other.length), который мы сюда передаем как параметр,
    то мы уже сразу можем сделать вывод что эти 2 строки неравны. Поэтому можем сделать сразу возврат значения false
    Если поля равны, то пробегаем по строкам через for так как у них одинаковое колличество символов то мы можем итерироваться столько раз сколько символов либо  в одной либо в другой строчке, 
    поэтому можно взять просто поле length, так ка мы находимся в классе то оно нам подойдет. 
    Но для того чтобы ввести ясность можно написать вот так this->length
    в цикле пишем еще одно условие: если хотябы один элемент в массиве, который именно в текущем классе, который у нас хранит все char-ы, будет неравен, тому элементу, который находится в тойже позиции
    только в объекте other, который мы передали ему как параметр, то мы уже сразу можем понять что наши объекты между собой неравны и можем сразу вернуть false.
    Есть маленький ньюанс, не все ветви этого кода возвращают значение, если мы видим что переменные не равны между собой, мы возвращаем false
    и если мы находим хотябы 1 символ который в той же позиции не равен символу в другом объекте, мы возвращаем false и сразу выходим, 
    но если оба условия не выполнилось и длинна у нас одинаковая то логично что наши строки будут тоже одинаковые, поэтому  в этом случае мы возвращаем true,
    то есть мы дошли до такого момента когда мы точно можем сказать, что в этом случае наши с вами строчки абсолютно идентичны*/

    //ПЕРЕГРУЗКА ОПЕРАТОРА РАВЕНСТВА "=="
    bool operator ==(const StringEx& other)
    {
        if (this->length != other.length)
        {
            return false;
        }

        for (int i = 0; i < this->length; i++)
        {
            if (this->str[i] != other.str[i])
            {
                return false;
            }
        }
        return true;
    }

    /*в данном случее метод operator !=() рекурсивно вызовет метод operator==() и вернет результат метода  operator==(),но операция не равно по своей сути инверсивна 
    и возвращает инверсированный результат, поэтому если мы получим в методе operator==() true, то в метод operator !=() вернется false*/

    //ПЕРЕГРУЗКА ОПЕРАТОРА НЕРАВЕНСТВА "!="
    bool operator !=(const StringEx& other)
    {
        return (!(this->operator==(other)));
    }

    void print()
    {
        cout << str << endl;
    }

    //ДЕСТРУКТОР,отвечает за освобождение ресурсов занятых объектом, вызывается при уничтожении объекта класса
    ~StringEx()
    {
        delete[] this->str;
    }
};

